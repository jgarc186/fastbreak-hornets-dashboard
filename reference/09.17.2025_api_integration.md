# 09.17.2025 Real API Integration Implementation Plan

## Overview
Transform the Charlotte Hornets dashboard from mock data to real Ball Don't Lie API data integration, including data structure alignment, API route creation, and component updates.

## Current State Analysis

### Mock Data Structure (Current):
**Existing Player Interface** (maintain compatibility):
```typescript
// This interface already exists in the project
export interface Player {
  id: number;
  name: string;
  position: string;
  pointsPerGame: number;
  rebounds: number;
  assists: number;
  fieldGoalPercentage: number;
  threePointPercentage: number;
  minutesPlayed: number;
  gamesPlayed: number;
}
```

### Ball Don't Lie API Response Structure:
```typescript
interface ApiPlayerStats {
  player_id: number;
  name: string; // Combined from first_name + last_name
  pts: number; // Points per game
  reb: number; // Rebounds per game
  ast: number; // Assists per game
  fg_pct: number; // Field goal percentage (decimal, not percentage)
  fg3_pct: number; // Three-point percentage (decimal)
  min: string; // Minutes played per game (string format)
  games_played: number;
  // Missing: position data (need separate solution)
}
```

## Implementation Steps

### Step 1: Update Project Dependencies
Ensure required packages are installed:

```json
{
  "dependencies": {
    "axios": "latest"
  }
}
```

Add environment variable to `.env.local`:
```
BALLDONTLIE_API_KEY=your_actual_api_key_here
```

### Step 2: Create API Route
Create the Next.js API route to fetch Hornets data.

**File Location**: `app/api/hornets-stats/route.ts` (App Router) or `pages/api/hornets-stats.js` (Pages Router)

**Key Requirements**:
- Use Charlotte Hornets team ID: `6`
- Fetch both player roster and season averages
- Combine player info with stats data
- Transform API response to match existing `Player` interface (no changes needed to interface)
- Handle errors gracefully
- Add proper TypeScript types

### Step 3: Create Data Transformation Layer
Create utility functions to transform API data to match existing component interfaces.

**File Location**: `lib/apiTransforms.ts`

**Required Transformations**:
```typescript
// Transform API response to match existing Player interface
export function transformApiDataToPlayer(apiData: ApiPlayerStats[]): Player[] {
  return apiData.map(player => ({
    id: player.player_id,
    name: player.name,
    position: "TBD", // Handle position data separately
    pointsPerGame: player.pts,
    rebounds: player.reb,
    assists: player.ast,
    fieldGoalPercentage: player.fg_pct * 100, // Convert decimal to percentage
    threePointPercentage: player.fg3_pct * 100, // Convert decimal to percentage
    minutesPlayed: parseFloat(player.min), // Convert string to number
    gamesPlayed: player.games_played
  }));
}
```

### Step 4: Handle Missing Position Data
The Ball Don't Lie API doesn't provide position data. Options:

**Option A**: Create static position mapping
```typescript
const PLAYER_POSITIONS: Record<string, string> = {
  "LaMelo Ball": "PG",
  "Terry Rozier": "SG",
  // ... etc
};
```

**Option B**: Remove position dependency from charts
**Option C**: Use secondary API or manual data entry

**Recommended**: Start with Option A for quick implementation.

### Step 5: Update Dashboard Data Flow

#### Current Data Flow:
```typescript
// DashboardContent.tsx
<PlayerLeaderboard players={charlotteHornetsPlayers} />
```

#### New Data Flow:
```typescript
// DashboardContent.tsx
const [playersData, setPlayersData] = useState<Player[]>([]);
const [loading, setLoading] = useState(true);
const [error, setError] = useState<string | null>(null);

useEffect(() => {
  fetchHornetsStats();
}, []);

// Pass real data to components
<PlayerLeaderboard players={playersData} loading={loading} error={error} />
```

### Step 6: Update Each Chart Component

#### Add Loading & Error States to Components:
All chart components need to handle:
- Loading states with Hornets-themed spinners
- Error states with retry functionality  
- Empty data states

#### Component Interface Updates:
```typescript
interface ChartProps {
  players: Player[];
  loading?: boolean;
  error?: string | null;
  onRetry?: () => void;
}
```

#### Update Components:
1. **PlayerLeaderboard**: Add loading skeleton using `.hornets-pulse`
2. **ShootingEfficiency**: Add error handling for missing shooting data
3. **PointsDistribution**: Handle players with 0 points
4. **PerformanceRadarChart**: Add fallback for incomplete stat categories

### Step 7: Implement Caching Strategy

#### Browser-Level Caching:
- Cache API responses for 5-10 minutes
- Use localStorage or sessionStorage for offline capability
- Implement "last updated" timestamps

#### API-Level Caching:
- Consider implementing Redis or in-memory caching
- Cache responses for 15-30 minutes (stats don't update frequently)

### Step 8: Error Handling & User Experience

#### API Error Scenarios:
1. **API Key Issues**: Show configuration error message
2. **Rate Limiting**: Implement retry with exponential backoff
3. **Network Failures**: Show retry button with error message
4. **No Data**: Handle players with no season stats

#### User-Friendly Error Messages:
```typescript
const ERROR_MESSAGES = {
  API_KEY: "Unable to fetch stats. Please check API configuration.",
  NETWORK: "Network error. Please check your connection and try again.",
  NO_DATA: "No stats available for the current season.",
  RATE_LIMIT: "Too many requests. Please wait a moment and try again."
};
```

### Step 9: Maintain Hornets Theming During Transitions

#### Loading States:
```tsx
{loading ? (
  <div className="stats-card hornets-pulse">
    <div className="h-64 bg-hornets-light-teal opacity-20 rounded flex items-center justify-center">
      <span className="basketball-bounce text-hornets-purple">
        Fetching latest Hornets stats...
      </span>
    </div>
  </div>
) : (
  <PlayerLeaderboard players={playersData} />
)}
```

#### Error States:
```tsx
{error ? (
  <div className="stats-card border-red-200 bg-red-50">
    <div className="text-hornets-purple font-semibold mb-2">
      Unable to load player stats
    </div>
    <p className="text-hornets-teal text-sm mb-4">{error}</p>
    <button 
      onClick={retryFetch}
      className="bg-hornets-teal text-white px-4 py-2 rounded hover:bg-hornets-dark-purple"
    >
      Try Again
    </button>
  </div>
) : null}
```

### Step 10: Testing & Validation

#### Data Validation:
- Verify all mock data players appear in API results
- Check that percentages are properly converted (decimal to percentage)
- Ensure minutes are properly parsed from string to number
- Validate that charts render correctly with real data

#### Performance Testing:
- Measure API response times
- Test loading states on slow connections
- Verify caching is working properly
- Test error scenarios (disconnect network, invalid API key)

## Implementation Priority

### Phase 1 (Critical):
1. Create API route
2. Create data transformation utilities
3. Update Player interface if needed
4. Add basic loading states to dashboard

### Phase 2 (Important):
1. Add comprehensive error handling
2. Implement position data solution
3. Add retry functionality
4. Update all chart components with loading/error states

### Phase 3 (Nice to Have):
1. Implement caching strategy
2. Add data refresh functionality
3. Add "last updated" indicators
4. Optimize performance

## Success Criteria
- Dashboard loads real Hornets data instead of mock data
- All existing chart functionality works with real data
- Loading states maintain Hornets branding
- Error handling provides helpful user feedback
- Performance is acceptable (< 3 second load times)
- Data updates reflect current season statistics

## Future Supabase Integration Notes
When implementing Supabase:
- Store API responses in Supabase tables
- Implement scheduled data updates
- Add data versioning/history
- Consider real-time updates during games
- Add analytics on data usage patterns
