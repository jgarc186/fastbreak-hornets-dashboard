# 09.17.2025 Real API Integration Implementation Plan

## Overview
Transform the Charlotte Hornets dashboard from mock data to real Ball Don't Lie API data integration, including data structure alignment, API route creation, and component updates.

## Current State Analysis

### Mock Data Structure (Current):
**Existing Player Interface** (maintain compatibility):
```typescript
// This interface already exists in the project
export interface Player {
  id: number;
  name: string;
  position: string;
  pointsPerGame: number;
  rebounds: number;
  assists: number;
  fieldGoalPercentage: number;
  threePointPercentage: number;
  minutesPlayed: number;
  gamesPlayed: number;
}
```

### Ball Don't Lie API Response Structure (Actual):
```typescript
interface ApiPlayerStats {
  player_id: number;
  pts: number; // Points per game
  ast: number; // Assists per game
  reb: number; // Total rebounds per game
  oreb: number; // Offensive rebounds per game
  dreb: number; // Defensive rebounds per game
  fg_pct: number; // Field goal percentage (decimal, not percentage)
  fg3_pct: number; // Three-point percentage (decimal)
  ft_pct: number; // Free throw percentage (decimal)
  fga: number; // Field goal attempts per game
  fgm: number; // Field goal makes per game
  fg3a: number; // Three-point attempts per game
  fg3m: number; // Three-point makes per game
  fta: number; // Free throw attempts per game
  ftm: number; // Free throw makes per game
  min: string; // Minutes played per game (format: "16:27")
  games_played: number;
  stl: number; // Steals per game
  blk: number; // Blocks per game
  turnover: number; // Turnovers per game
  pf: number; // Personal fouls per game
  season: number;
}

// API returns: { "data": [ApiPlayerStats] }
interface ApiSeasonAveragesResponse {
  data: ApiPlayerStats[];
}
```

## Implementation Steps

### Step 1: Update Project Dependencies
Ensure required packages are installed:

```json
{
  "dependencies": {
    "axios": "latest"
  }
}
```

Add environment variable to `.env.local`:
```
BALLDONTLIE_API_KEY=your_actual_api_key_here
```

### Step 2: Create API Route
Create the Next.js API route to fetch Hornets data.

**File Location**: `app/api/hornets-stats/route.ts` (App Router) or `pages/api/hornets-stats.js` (Pages Router)

**Key Requirements**:
- Use Charlotte Hornets team ID: `4` (confirmed from teams endpoint)
- **Important**: API requires separate calls for each player's season averages
- Make one call to get roster, then individual calls for each player's stats
- Handle rate limiting (multiple API calls required)
- Transform API response to match existing `Player` interface
- Handle players with no season stats gracefully
- Convert minutes format from "16:27" to decimal (16.45)
- Add proper TypeScript types

**API Endpoint Pattern**:
1. Get team roster: `GET /players?team_ids[]=4&per_page=100`
2. Get individual stats: `GET /season_averages?player_id=12&season=2024` (one call per player)

### Step 3: Create Data Transformation Layer
Create utility functions to transform API data to match existing component interfaces.

**File Location**: `lib/apiTransforms.ts`

**Required Transformations**:
```typescript
// Transform API response to match existing Player interface
export function transformApiDataToPlayer(players: any[], statsData: ApiPlayerStats[]): Player[] {
  return players.map(player => {
    const stats = statsData.find(stat => stat.player_id === player.id);
    
    // Handle missing stats gracefully
    if (!stats) {
      return null;
    }
    
    return {
      id: player.id,
      name: `${player.first_name} ${player.last_name}`,
      position: player.position || "N/A", // Use position from player data
      pointsPerGame: stats.pts,
      rebounds: stats.reb,
      assists: stats.ast,
      fieldGoalPercentage: stats.fg_pct * 100, // Convert decimal to percentage
      threePointPercentage: stats.fg3_pct * 100, // Convert decimal to percentage
      minutesPlayed: parseMinutesToDecimal(stats.min), // Convert "16:27" to 16.45
      gamesPlayed: stats.games_played
    };
  }).filter(Boolean); // Remove null entries
}

// Helper function to convert "16:27" format to decimal
function parseMinutesToDecimal(minString: string): number {
  const [minutes, seconds] = minString.split(':').map(Number);
  return minutes + (seconds / 60);
}
```

### Step 4: Handle Missing Position Data
The Ball Don't Lie API doesn't provide position data. Options:

**Option A**: Create static position mapping
```typescript
const PLAYER_POSITIONS: Record<string, string> = {
  "LaMelo Ball": "PG",
  "Terry Rozier": "SG",
  // ... etc
};
```

**Option B**: Remove position dependency from charts
**Option C**: Use secondary API or manual data entry

**Recommended**: Start with Option A for quick implementation.

### Step 5: Update Dashboard Data Flow

#### Current Data Flow:
```typescript
// DashboardContent.tsx
<PlayerLeaderboard players={charlotteHornetsPlayers} />
```

#### New Data Flow:
```typescript
// DashboardContent.tsx
const [playersData, setPlayersData] = useState<Player[]>([]);
const [loading, setLoading] = useState(true);
const [error, setError] = useState<string | null>(null);

useEffect(() => {
  fetchHornetsStats();
}, []);

// Pass real data to components
<PlayerLeaderboard players={playersData} loading={loading} error={error} />
```

### Step 6: Update Each Chart Component

#### Add Loading & Error States to Components:
All chart components need to handle:
- Loading states with Hornets-themed spinners
- Error states with retry functionality  
- Empty data states

#### Component Interface Updates:
```typescript
interface ChartProps {
  players: Player[];
  loading?: boolean;
  error?: string | null;
  onRetry?: () => void;
}
```

#### Update Components:
1. **PlayerLeaderboard**: Add loading skeleton using `.hornets-pulse`
2. **ShootingEfficiency**: Add error handling for missing shooting data
3. **PointsDistribution**: Handle players with 0 points
4. **PerformanceRadarChart**: Add fallback for incomplete stat categories

### Step 7: Implement Caching Strategy

#### Browser-Level Caching:
- Cache API responses for 5-10 minutes
- Use localStorage or sessionStorage for offline capability
- Implement "last updated" timestamps

#### API-Level Caching:
- Consider implementing Redis or in-memory caching
- Cache responses for 15-30 minutes (stats don't update frequently)

### Step 8: Error Handling & User Experience

#### API Error Scenarios:
1. **API Key Issues**: Show configuration error message
2. **Rate Limiting**: Implement retry with exponential backoff
3. **Network Failures**: Show retry button with error message
4. **No Data**: Handle players with no season stats

#### User-Friendly Error Messages:
```typescript
const ERROR_MESSAGES = {
  API_KEY: "Unable to fetch stats. Please check API configuration.",
  NETWORK: "Network error. Please check your connection and try again.",
  NO_DATA: "No stats available for the current season.",
  RATE_LIMIT: "Too many requests. Please wait a moment and try again."
};
```

### Step 9: Maintain Hornets Theming During Transitions

#### Loading States:
```tsx
{loading ? (
  <div className="stats-card hornets-pulse">
    <div className="h-64 bg-hornets-light-teal opacity-20 rounded flex items-center justify-center">
      <span className="basketball-bounce text-hornets-purple">
        Fetching latest Hornets stats...
      </span>
    </div>
  </div>
) : (
  <PlayerLeaderboard players={playersData} />
)}
```

#### Error States:
```tsx
{error ? (
  <div className="stats-card border-red-200 bg-red-50">
    <div className="text-hornets-purple font-semibold mb-2">
      Unable to load player stats
    </div>
    <p className="text-hornets-teal text-sm mb-4">{error}</p>
    <button 
      onClick={retryFetch}
      className="bg-hornets-teal text-white px-4 py-2 rounded hover:bg-hornets-dark-purple"
    >
      Try Again
    </button>
  </div>
) : null}
```

### Step 10: Testing & Validation

#### Data Validation:
- Verify all mock data players appear in API results
- Check that percentages are properly converted (decimal to percentage)
- Ensure minutes are properly parsed from string to number
- Validate that charts render correctly with real data

#### Performance Testing:
- Measure API response times
- Test loading states on slow connections
- Verify caching is working properly
- Test error scenarios (disconnect network, invalid API key)

## Implementation Priority

### Phase 1 (Critical):
1. Create API route
2. Create data transformation utilities
3. Update Player interface if needed
4. Add basic loading states to dashboard

### Phase 2 (Important):
1. Add comprehensive error handling
2. Implement position data solution
3. Add retry functionality
4. Update all chart components with loading/error states

### Phase 3 (Nice to Have):
1. Implement caching strategy
2. Add data refresh functionality
3. Add "last updated" indicators
4. Optimize performance

## Success Criteria
- Dashboard loads real Hornets data instead of mock data
- All existing chart functionality works with real data
- Loading states maintain Hornets branding
- Error handling provides helpful user feedback
- Performance is acceptable (< 3 second load times)
- Data updates reflect current season statistics

## Future Supabase Integration Notes
When implementing Supabase:
- Store API responses in Supabase tables
- Implement scheduled data updates
- Add data versioning/history
- Consider real-time updates during games
- Add analytics on data usage patterns
