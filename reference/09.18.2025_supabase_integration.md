# 09.18.2025 Supabase Integration Plan - Rate Limit Mitigation

## Overview
Integrate Supabase as a caching layer to store Charlotte Hornets player data and statistics, eliminating rate limit issues and providing fast user experiences by reducing direct API calls to Ball Don't Lie API.

## Problem Statement
- Ball Don't Lie API has strict rate limits
- Each dashboard load requires 15-20 individual API calls (one per player)
- Multiple users accessing the system simultaneously causes rate limit violations
- Slow loading times due to sequential API calls
- 401 errors when rate limits are exceeded

## Solution Architecture

### Data Flow Strategy
```
Ball Don't Lie API → Supabase (Cache) → Next.js App → Users
     (Daily)           (Fast Access)    (Instant)
```

**Current Flow (Problem):**
```
User Request → Next.js API → 20 Ball Don't Lie API calls → Response (slow + rate limits)
```

**New Flow (Solution):**
```
User Request → Next.js API → Supabase Query → Response (fast + no rate limits)
Background Job → Ball Don't Lie API → Update Supabase (daily/scheduled)
```

## Supabase Database Schema

### Table 1: `hornets_players`
```sql
CREATE TABLE hornets_players (
  id SERIAL PRIMARY KEY,
  api_player_id INTEGER UNIQUE NOT NULL, -- Ball Don't Lie player ID
  first_name TEXT NOT NULL,
  last_name TEXT NOT NULL,
  full_name TEXT NOT NULL,
  position TEXT,
  height_feet INTEGER,
  height_inches INTEGER,
  weight_pounds INTEGER,
  team_id INTEGER NOT NULL DEFAULT 4, -- Charlotte Hornets
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### Table 2: `player_season_stats`
```sql
CREATE TABLE player_season_stats (
  id SERIAL PRIMARY KEY,
  api_player_id INTEGER REFERENCES hornets_players(api_player_id),
  season INTEGER NOT NULL,
  games_played INTEGER,
  minutes_per_game DECIMAL(4,1), -- Converted from "MM:SS" to decimal
  points_per_game DECIMAL(4,1),
  rebounds_per_game DECIMAL(4,1),
  assists_per_game DECIMAL(4,1),
  steals_per_game DECIMAL(4,1),
  blocks_per_game DECIMAL(4,1),
  turnovers_per_game DECIMAL(4,1),
  field_goal_percentage DECIMAL(5,1), -- Stored as percentage (43.5)
  three_point_percentage DECIMAL(5,1), -- Stored as percentage (37.1)
  free_throw_percentage DECIMAL(5,1), -- Stored as percentage (85.2)
  field_goals_made DECIMAL(4,1),
  field_goals_attempted DECIMAL(4,1),
  three_pointers_made DECIMAL(4,1),
  three_pointers_attempted DECIMAL(4,1),
  free_throws_made DECIMAL(4,1),
  free_throws_attempted DECIMAL(4,1),
  offensive_rebounds DECIMAL(4,1),
  defensive_rebounds DECIMAL(4,1),
  personal_fouls DECIMAL(4,1),
  last_api_update TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(api_player_id, season)
);
```

### Table 3: `data_sync_log`
```sql
CREATE TABLE data_sync_log (
  id SERIAL PRIMARY KEY,
  sync_type TEXT NOT NULL, -- 'players' or 'stats'
  season INTEGER,
  status TEXT NOT NULL, -- 'success', 'partial', 'failed'
  players_synced INTEGER DEFAULT 0,
  errors_encountered INTEGER DEFAULT 0,
  api_calls_made INTEGER DEFAULT 0,
  sync_duration_seconds INTEGER,
  error_details JSONB,
  started_at TIMESTAMP WITH TIME ZONE,
  completed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

## Implementation Steps

### Step 1: Supabase Setup
1. **Create Supabase Project**
   - Set up new project at supabase.com
   - Note the project URL and anon key
   - Configure database in the SQL Editor

2. **Install Supabase Client**
   ```bash
   npm install @supabase/supabase-js
   ```

3. **Environment Variables**
   ```env
   NEXT_PUBLIC_SUPABASE_URL=your_supabase_project_url
   NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
   SUPABASE_SERVICE_ROLE_KEY=your_service_role_key
   BALLDONTLIE_API_KEY=your_ball_dont_lie_api_key
   ```

### Step 2: Create Supabase Client Configuration
**File**: `lib/supabase.ts`
```typescript
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

export const supabase = createClient(supabaseUrl, supabaseKey)

// Server-side client with service role
export const supabaseAdmin = createClient(
  supabaseUrl,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)
```

### Step 3: Data Synchronization API Routes

#### 3.1: Manual Sync Route (Development/Testing)
**File**: `app/api/sync-hornets-data/route.ts`
- Fetch all Hornets players from Ball Don't Lie API
- Store/update players in `hornets_players` table
- Fetch season stats for each player (with rate limiting)
- Store/update stats in `player_season_stats` table
- Log sync results in `data_sync_log` table
- Return sync summary and any errors

#### 3.2: Automated Background Sync (Production)
**Options for Implementation**:

**Option A: Vercel Cron Jobs**
```typescript
// app/api/cron/daily-sync/route.ts
export async function GET() {
  // Verify cron secret
  if (request.nextUrl.searchParams.get('secret') !== process.env.CRON_SECRET) {
    return new Response('Unauthorized', { status: 401 });
  }
  
  // Perform data sync
  return syncHornetsData();
}
```

**Option B: Supabase Edge Functions**
```sql
-- Schedule daily sync at 6 AM EST
SELECT cron.schedule('daily-hornets-sync', '0 6 * * *', 'SELECT sync_hornets_data();');
```

**Option C: GitHub Actions (Recommended)**
```yaml
# .github/workflows/sync-data.yml
name: Daily Hornets Data Sync
on:
  schedule:
    - cron: '0 10 * * *'  # 6 AM EST (10 AM UTC)
  workflow_dispatch:  # Manual trigger

jobs:
  sync-data:
    runs-on: ubuntu-latest
    steps:
      - name: Trigger data sync
        run: |
          curl -X POST "${{ secrets.VERCEL_APP_URL }}/api/sync-hornets-data" \
            -H "Authorization: Bearer ${{ secrets.SYNC_API_KEY }}"
```

### Step 4: Update Data Fetching Logic

#### 4.1: New Supabase-First API Route
**File**: `app/api/hornets-stats/route.ts`

```typescript
export async function GET() {
  try {
    // Try Supabase first
    const { data: playersData, error } = await supabase
      .from('hornets_players')
      .select(`
        *,
        player_season_stats!inner(*)
      `)
      .eq('is_active', true)
      .eq('player_season_stats.season', 2024);

    if (error) throw error;

    // Transform Supabase data to match Player interface
    const transformedData = playersData.map(transformSupabaseToPlayer);
    
    return NextResponse.json(transformedData);

  } catch (error) {
    console.error('Supabase fetch failed:', error);
    
    // Fallback to direct API call (for emergencies)
    return fallbackToDirectAPI();
  }
}
```

#### 4.2: Data Transformation Functions
**File**: `lib/dataTransforms.ts`

```typescript
export function transformSupabaseToPlayer(supabaseData: any): Player {
  const stats = supabaseData.player_season_stats[0];
  
  return {
    id: supabaseData.api_player_id,
    name: supabaseData.full_name,
    position: supabaseData.position || 'N/A',
    pointsPerGame: stats.points_per_game,
    rebounds: stats.rebounds_per_game,
    assists: stats.assists_per_game,
    fieldGoalPercentage: stats.field_goal_percentage,
    threePointPercentage: stats.three_point_percentage,
    minutesPlayed: stats.minutes_per_game,
    gamesPlayed: stats.games_played
  };
}

export function transformBallDontLieToSupabase(playerData: any, statsData: any) {
  return {
    // Player data transformation
    playerInsert: {
      api_player_id: playerData.id,
      first_name: playerData.first_name,
      last_name: playerData.last_name,
      full_name: `${playerData.first_name} ${playerData.last_name}`,
      position: playerData.position,
      height_feet: playerData.height_feet,
      height_inches: playerData.height_inches,
      weight_pounds: playerData.weight_pounds
    },
    // Stats data transformation  
    statsInsert: {
      api_player_id: playerData.id,
      season: 2024,
      games_played: statsData.games_played,
      minutes_per_game: parseMinutesToDecimal(statsData.min),
      points_per_game: statsData.pts,
      rebounds_per_game: statsData.reb,
      assists_per_game: statsData.ast,
      // ... other stats fields
      field_goal_percentage: statsData.fg_pct * 100,
      three_point_percentage: statsData.fg3_pct * 100,
      free_throw_percentage: statsData.ft_pct * 100
    }
  };
}
```

### Step 5: Dashboard Component Updates

#### 5.1: Add Data Freshness Indicators
```typescript
// Show when data was last updated
const [lastUpdated, setLastUpdated] = useState<Date | null>(null);

// Fetch last sync time from Supabase
useEffect(() => {
  fetchLastSyncTime();
}, []);
```

#### 5.2: Manual Refresh Capability
```typescript
// Add refresh button for users to trigger data sync if needed
const handleManualRefresh = async () => {
  setRefreshing(true);
  await fetch('/api/sync-hornets-data', { method: 'POST' });
  await refetchData();
  setRefreshing(false);
};
```

## Rate Limiting & Performance Strategy

### API Call Optimization
```typescript
// Implement delays between API calls during sync
const RATE_LIMIT_DELAY = 100; // 100ms between calls

for (let i = 0; i < playerIds.length; i++) {
  const playerId = playerIds[i];
  
  // Fetch stats for this player
  await fetchPlayerStats(playerId);
  
  // Wait before next call (except for last player)
  if (i < playerIds.length - 1) {
    await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_DELAY));
  }
}
```

### Error Recovery Strategy
```typescript
// Implement exponential backoff for failed API calls
async function fetchWithRetry(url: string, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await axios.get(url, { headers });
      return response;
    } catch (error) {
      if (error.response?.status === 429 && attempt < maxRetries) {
        // Rate limited, wait and retry
        const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      throw error;
    }
  }
}
```

## Data Freshness Strategy

### Update Frequency
- **Player Roster**: Update weekly (roster changes are rare)
- **Season Stats**: Update daily during season, weekly during off-season
- **Real-time During Games**: Consider separate endpoint for live game stats

### Cache Invalidation
```typescript
// Add cache headers to API responses
export async function GET() {
  const data = await fetchFromSupabase();
  
  return NextResponse.json(data, {
    headers: {
      'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400'
      // Cache for 1 hour, serve stale for 24 hours while revalidating
    }
  });
}
```

## Monitoring & Analytics

### Sync Monitoring Dashboard
Create admin dashboard to monitor:
- Last successful sync timestamp
- Number of players synced
- API calls made vs rate limit
- Sync duration and performance
- Error logs and failed player syncs

### User Experience Metrics
Track:
- Dashboard load times (before/after Supabase)
- Cache hit rates
- User bounce rates due to loading times
- API error rates experienced by users

## Security Considerations

### Row Level Security (RLS)
```sql
-- Enable RLS on tables
ALTER TABLE hornets_players ENABLE ROW LEVEL SECURITY;
ALTER TABLE player_season_stats ENABLE ROW LEVEL SECURITY;

-- Allow public read access to stats (read-only dashboard)
CREATE POLICY "Allow public read access" ON hornets_players 
  FOR SELECT USING (true);

CREATE POLICY "Allow public read access" ON player_season_stats 
  FOR SELECT USING (true);
```

### API Key Security
- Store Ball Don't Lie API key in Vercel environment variables
- Use Supabase service role key only in server-side functions
- Implement API route protection for sync endpoints

## Success Metrics

### Performance Goals
- Dashboard load time: < 2 seconds (vs current 10+ seconds)
- API rate limit errors: 0% (vs current frequent 401s)
- User experience: No loading delays for stats data
- Data freshness: Stats updated daily, never more than 24 hours old

### Development Goals
- Reduced Ball Don't Lie API calls by 95%
- Improved scalability for multiple concurrent users
- Automated data management with monitoring
- Backup/fallback system for API failures

## Implementation Timeline

### Phase 1 (Week 1): Foundation
- Set up Supabase project and database schema
- Create data transformation utilities
- Implement manual sync API route

### Phase 2 (Week 2): Integration  
- Update dashboard to use Supabase data
- Add loading states and error handling
- Implement data freshness indicators

### Phase 3 (Week 3): Automation
- Set up scheduled daily syncs
- Add monitoring and logging
- Performance optimization and caching

### Phase 4 (Week 4): Polish
- Admin dashboard for sync monitoring
- Error recovery and retry logic
- Documentation and deployment

This implementation will solve the rate limiting problem while providing users with a fast, reliable experience accessing Charlotte Hornets statistics!
