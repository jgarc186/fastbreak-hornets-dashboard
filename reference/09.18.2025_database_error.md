# Supabase Query Syntax Fix - PGRST100 Error Resolution

## Issue Description
The Supabase query is failing with error:
```
code: 'PGRST100'
message: "failed to parse order (player_season_stats.points_per_game.desc)"
```

**Root Cause**: Incorrect syntax for ordering by columns in joined tables. Supabase PostgREST doesn't support ordering by related table columns using dot notation in the `.order()` method.

## Current Problematic Code
The error is occurring because of this type of query syntax:
```typescript
// ❌ This syntax causes PGRST100 error
.order('player_season_stats.points_per_game.desc')
// or
.order('player_season_stats.points_per_game', { ascending: false })
```

## Solution Options

### Option 1: Quick Fix - Remove Problematic Ordering (Immediate)
**File**: `app/api/hornets-stats/route.ts`

**Replace the problematic query with**:
```typescript
const { data: playersData, error } = await supabase
  .from('hornets_players')
  .select(`
    *,
    player_season_stats!inner(*)
  `)
  .eq('is_active', true)
  .eq('player_season_stats.season', 2024)
  .order('full_name', { ascending: true }); // Order by player name instead
```

### Option 2: Database View Approach (Recommended)
**Step 1**: Create a database view in Supabase SQL Editor

**File**: Run this SQL in Supabase Dashboard → SQL Editor:
```sql
-- Create a flattened view that combines players and stats
CREATE OR REPLACE VIEW hornets_current_stats AS
SELECT 
  -- Player information
  hp.api_player_id as id,
  hp.full_name as name,
  hp.position,
  hp.first_name,
  hp.last_name,
  hp.height_feet,
  hp.height_inches,
  hp.weight_pounds,
  hp.is_active,
  
  -- Season statistics  
  pss.season,
  pss.games_played,
  pss.minutes_per_game,
  pss.points_per_game,
  pss.rebounds_per_game,
  pss.assists_per_game,
  pss.steals_per_game,
  pss.blocks_per_game,
  pss.turnovers_per_game,
  pss.field_goal_percentage,
  pss.three_point_percentage,
  pss.free_throw_percentage,
  pss.field_goals_made,
  pss.field_goals_attempted,
  pss.three_pointers_made,
  pss.three_pointers_attempted,
  pss.free_throws_made,
  pss.free_throws_attempted,
  pss.offensive_rebounds,
  pss.defensive_rebounds,
  pss.personal_fouls,
  pss.last_api_update,
  
  -- Computed fields for easy access
  hp.created_at as player_created_at,
  pss.created_at as stats_created_at

FROM hornets_players hp
INNER JOIN player_season_stats pss ON hp.api_player_id = pss.api_player_id
WHERE hp.is_active = true AND pss.season = 2024;
```

**Step 2**: Update the API route to use the view

**File**: `app/api/hornets-stats/route.ts`
```typescript
export async function GET() {
  try {
    console.log('Fetching Hornets data from Supabase view...');
    
    const { data: playersData, error } = await supabase
      .from('hornets_current_stats')
      .select('*')
      .order('points_per_game', { ascending: false }); // Now this works!

    if (error) {
      console.error('Supabase query error:', error);
      throw error;
    }

    if (!playersData || playersData.length === 0) {
      console.log('No player data found in Supabase');
      return NextResponse.json({ error: 'No player data found' }, { status: 404 });
    }

    console.log(`Found ${playersData.length} players in Supabase`);

    // Transform the flattened view data to match Player interface
    const transformedData: Player[] = playersData.map((player: any) => ({
      id: player.id,
      name: player.name,
      position: player.position || 'N/A',
      pointsPerGame: player.points_per_game || 0,
      rebounds: player.rebounds_per_game || 0,
      assists: player.assists_per_game || 0,
      fieldGoalPercentage: player.field_goal_percentage || 0,
      threePointPercentage: player.three_point_percentage || 0,
      minutesPlayed: player.minutes_per_game || 0,
      gamesPlayed: player.games_played || 0
    }));

    return NextResponse.json(transformedData);

  } catch (error) {
    console.error('Failed to fetch from Supabase:', error);
    
    // Optional: Fallback to direct API call
    return NextResponse.json(
      { error: 'Failed to fetch player data from database' }, 
      { status: 500 }
    );
  }
}
```

### Option 3: JavaScript Sorting (Alternative)
**File**: `app/api/hornets-stats/route.ts`

```typescript
export async function GET() {
  try {
    const { data: playersData, error } = await supabase
      .from('hornets_players')
      .select(`
        *,
        player_season_stats!inner(*)
      `)
      .eq('is_active', true)
      .eq('player_season_stats.season', 2024);

    if (error) throw error;

    // Sort in JavaScript after fetching
    const sortedPlayers = playersData.sort((a, b) => {
      const aPoints = a.player_season_stats[0]?.points_per_game || 0;
      const bPoints = b.player_season_stats[0]?.points_per_game || 0;
      return bPoints - aPoints; // Descending order by points
    });

    // Transform data...
    const transformedData = sortedPlayers.map(transformSupabaseToPlayer);
    
    return NextResponse.json(transformedData);
  } catch (error) {
    // Error handling...
  }
}
```

## Data Transformation Updates

### Update the transformation function for the view approach:
**File**: `lib/dataTransforms.ts`

```typescript
// For the database view approach (Option 2)
export function transformSupabaseViewToPlayer(viewData: any): Player {
  return {
    id: viewData.id,
    name: viewData.name,
    position: viewData.position || 'N/A',
    pointsPerGame: viewData.points_per_game || 0,
    rebounds: viewData.rebounds_per_game || 0,
    assists: viewData.assists_per_game || 0,
    fieldGoalPercentage: viewData.field_goal_percentage || 0,
    threePointPercentage: viewData.three_point_percentage || 0,
    minutesPlayed: viewData.minutes_per_game || 0,
    gamesPlayed: viewData.games_played || 0
  };
}

// For the existing nested approach (Option 3)
export function transformSupabaseToPlayer(supabaseData: any): Player {
  const stats = supabaseData.player_season_stats[0];
  
  if (!stats) {
    // Handle players without stats
    return {
      id: supabaseData.api_player_id,
      name: supabaseData.full_name,
      position: supabaseData.position || 'N/A',
      pointsPerGame: 0,
      rebounds: 0,
      assists: 0,
      fieldGoalPercentage: 0,
      threePointPercentage: 0,
      minutesPlayed: 0,
      gamesPlayed: 0
    };
  }
  
  return {
    id: supabaseData.api_player_id,
    name: supabaseData.full_name,
    position: supabaseData.position || 'N/A',
    pointsPerGame: stats.points_per_game || 0,
    rebounds: stats.rebounds_per_game || 0,
    assists: stats.assists_per_game || 0,
    fieldGoalPercentage: stats.field_goal_percentage || 0,
    threePointPercentage: stats.three_point_percentage || 0,
    minutesPlayed: stats.minutes_per_game || 0,
    gamesPlayed: stats.games_played || 0
  };
}
```

## Implementation Priority

### Immediate Fix (5 minutes):
Use **Option 1** to get the system working immediately - just remove the problematic ordering.

### Best Long-term Solution (15 minutes):
Implement **Option 2** (Database View) because:
- ✅ Allows proper sorting by any statistical column
- ✅ Better performance (single table query vs joins)
- ✅ Cleaner TypeScript code
- ✅ Easier to add new sorting options later
- ✅ More maintainable

### Testing the Fix:
After implementing either solution, test with:
```bash
curl http://localhost:3000/api/hornets-stats
```

You should see a successful JSON response with Charlotte Hornets player data sorted properly.

## Additional Improvements (Optional)

### Add Multiple Sorting Options:
```typescript
// In your API route, accept query parameters for sorting
const sortBy = req.nextUrl.searchParams.get('sort') || 'points_per_game';
const order = req.nextUrl.searchParams.get('order') || 'desc';

const { data, error } = await supabase
  .from('hornets_current_stats')
  .select('*')
  .order(sortBy, { ascending: order === 'asc' });
```

### Add Caching Headers:
```typescript
return NextResponse.json(transformedData, {
  headers: {
    'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400'
  }
});
```

**Recommended Action**: Start with Option 1 for immediate fix, then implement Option 2 for the best long-term solution.
